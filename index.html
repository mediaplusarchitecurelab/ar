<!DOCTYPE html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Hello, AR Cube!</title>
	<!-- include three.js library -->
	<script type="text/javascript" src='js/three.js'></script>
	<!-- include jsartookit -->
	<script type="text/javascript" src="jsartoolkit5/artoolkit.min.js"></script>
	<script type="text/javascript" src="jsartoolkit5/artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script type="text/javascript" src="threex/threex-artoolkitsource.js"></script>
	<script type="text/javascript" src="threex/threex-artoolkitcontext.js"></script>
	<script type="text/javascript" src="threex/threex-arbasecontrols.js"></script>
	<script type="text/javascript" src="threex/threex-armarkercontrols.js"></script>
	<script type="text/javascript" src="dat/dat.gui.min.js"></script>
</head>
<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

<!-- 
  Example created by Lee Stemkoski: https://github.com/stemkoski
  Based on the AR.js library and examples created by Jerome Etienne: https://github.com/jeromeetienne/AR.js/
-->

<script>
	
    const qrxy = 1.00/500;	// qrcode 大小 單位為 mm 

    var obj = {
		team: 'team_1',
		applyteam: function () {
			preload(obj.team.split('_')[1]);
		},
		jointSize:6,
		pipeColor: [ 0, 128, 255 ],
	};
	var jointSizetemp = obj.jointSize;
    var pipeDegree = 20; // default as 64
    var pipeSize = 3*qrxy;
    var pipeRacial = 4;
    var pipeClose = false;

    var jointSize =obj.jointSize*qrxy;



    // Objects
    var scene =null;
    var camera, renderer, clock, deltaTime, totalTime;
	var arToolkitSource, arToolkitContext;
	var markerRoot1, markerRoot2;
	var nodelist=[];
	var crvlist=[];

	// GUI
	var gui=null;

	


	preload("1");
	
	// Load
	
	function preload(val){
		if (scene!==null){
			scene.remove.apply(scene, scene.children);
		}

		const ssnodeurl = 'https://spreadsheets.google.com/feeds/list/1l3DvxzJxmCPyk3TruBMCC_YXWEvRJXnkwaKcx41IoKA/'+(parseInt(val)*2+1).toString()+'/public/values?alt=json';
		const sscrvurl = 'https://spreadsheets.google.com/feeds/list/1l3DvxzJxmCPyk3TruBMCC_YXWEvRJXnkwaKcx41IoKA/'+(parseInt(val)*2+2).toString()+'/public/values?alt=json';

        // load url1
        fetch(ssnodeurl)
            .then((response)=>{
            return response.text();
        }).then((data)=>{
            // do url1data
            let val = JSON.parse(data);
            encodenode(val);            
        }).catch((error)=>{
            console.log(error);
        }).then(()=>{
        	// after load url1 load url2
        	fetch(sscrvurl)
                .then((response2)=>{
                	return response2.text();
                }).then((data2)=>{
                    // do url2data
                    let val2 = JSON.parse(data2);
                    encodecrv(val2);
                }).catch((error2)=>{
                    console.log(error2);
            }).then(()=>{
            	alert(obj.team +'model were loaded!!');
            	initialize();
				animate();	        	
            });
        });
    }

    function encodenode(data){
    	nodelist=[];// clear data

    	data.feed.entry.forEach ((val,i)=>{
    		let nidlocked = val.gsx$locked.$t === '0' ? false : true;
    		//let object = nidlocked ? new THREE.Mesh( geoMesh, matLocked ) : new THREE.Mesh( geoMesh, matFinished);
    		let vv = new THREE.Vector3( 
                parseFloat(val.gsx$x.$t)*qrxy*6,
                parseFloat(val.gsx$z.$t)*qrxy*6,
                parseFloat(val.gsx$y.$t)*qrxy*6);
            let vt = new THREE.Vector3( 
                parseFloat(val.gsx$nx.$t)*(-1),
                parseFloat(val.gsx$nz.$t)*(-1),
                parseFloat(val.gsx$ny.$t)*(-1));
            let tempmesh = new THREE.Mesh(
            				new THREE.CubeGeometry(jointSize,jointSize,jointSize),
            				new THREE.MeshNormalMaterial({
								transparent: true,
								opacity: 0.5,
								side: THREE.DoubleSide
							}));
            tempmesh.position.x = vv.x;
            tempmesh.position.y = vv.y
            tempmesh.position.z = vv.z;
            nodelist.push(tempmesh);
    	});
    }
    function encodecrv(data){
    	crvlist=[];// clear data

    	data.feed.entry.forEach ((val,i)=>{
    		let cidlocked = val.gsx$locked.$t === '0' ? false : true; 
    		let nidlstr = val.gsx$nid.$t.split('^');
    		// node pickup
            let npts = [];
            nidlstr.forEach((v)=>{
               npts.push(nodelist[parseInt(v)].position);
            });

    		let spl = new THREE.CatmullRomCurve3(npts);
            spl.curveType = 'catmullrom';
            let tub = new THREE.TubeBufferGeometry( spl, pipeDegree, pipeSize, pipeRacial, pipeClose );
			let tempmesh = new THREE.Mesh(
            				tub,
            				new THREE.MeshBasicMaterial({
            					color: new THREE.Color('rgb('+obj.pipeColor[0].toString()+','+obj.pipeColor[1].toString()+','+obj.pipeColor[2].toString()+')')
							}));
            crvlist.push(tempmesh);
    	});
    }
    

	function initialize()
	{
		if (gui===null){
			////////////////////////////////////////////////////////////
			// setup scene
			////////////////////////////////////////////////////////////
			scene = new THREE.Scene();

			let ambientLight = new THREE.AmbientLight( 0xcccccc, 0.5 );
			scene.add( ambientLight );
						
			camera = new THREE.Camera();
			scene.add(camera);

			renderer = new THREE.WebGLRenderer({
				antialias : true,
				alpha: true
			});
			renderer.setClearColor(new THREE.Color('lightgrey'), 0)
			renderer.setSize( 640, 480 );
			renderer.domElement.style.position = 'absolute'
			renderer.domElement.style.top = '0px'
			renderer.domElement.style.left = '0px'
			document.body.appendChild( renderer.domElement );

			clock = new THREE.Clock();
			deltaTime = 0;
			totalTime = 0;
			
			////////////////////////////////////////////////////////////
			// setup arToolkitSource
			////////////////////////////////////////////////////////////

			arToolkitSource = new THREEx.ArToolkitSource({
				sourceType : 'webcam',
			});

			function onResize()
			{
				arToolkitSource.onResize()	
				arToolkitSource.copySizeTo(renderer.domElement)	
				if ( arToolkitContext.arController !== null )
				{
					arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
				}	
			}

			arToolkitSource.init(function onReady(){
				onResize()
			});
			
			// handle resize event
			window.addEventListener('resize', function(){
				onResize()
			});
			
			////////////////////////////////////////////////////////////
			// setup arToolkitContext
			////////////////////////////////////////////////////////////	

			// create atToolkitContext
			arToolkitContext = new THREEx.ArToolkitContext({
				cameraParametersUrl: 'data/camera_para.dat',
				detectionMode: 'mono'
			});
			
			// copy projection matrix to camera when initialization complete
			arToolkitContext.init( function onCompleted(){
				camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
			});

			////////////////////////////////////////////////////////////
			// setup markerRoots
			////////////////////////////////////////////////////////////

			// build markerControls
			markerRoot1 = new THREE.Group();
			scene.add(markerRoot1);
			let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
				type: 'pattern', patternUrl: "data/hiro.patt",
			})	//pattern

			////////////////////////////////////////////////////////////
			// init GUI
			////////////////////////////////////////////////////////////
			// GUI content
			gui = new dat.gui.GUI();					
			// GUI into
			gui.add(obj, 'team', [ 'team_1', 'team_2'] );
			gui.add(obj, 'applyteam');
			
			gui.add(obj, 'jointSize').min(5).max(50).step(0.5).onChange((val)=> {
			    nodelist.forEach((m)=>{
					m.geometry = new THREE.CubeGeometry(val*qrxy,val*qrxy,val*qrxy);
				});
			 });

			gui.addColor(obj, 'pipeColor').onChange((val)=> {
				//console.log(val);
				let nm = new THREE.MeshBasicMaterial({
            					color: new THREE.Color(val[0],val[1],val[2])
							});
				console.log(nm);
			    crvlist.forEach((m)=>{
					m.material = nm;
					m.material.needsUpdate = true;
				});
			 });
		}
		////////////////////////////////////////////////////////////
		// apply geometry to marker
		////////////////////////////////////////////////////////////

		nodelist.forEach((m)=>{
			markerRoot1.add( m );
		});

		crvlist.forEach((c)=>{
			markerRoot1.add( c );
		});

	}


	function update()
	{
		// update artoolkit on every frame
		if ( arToolkitSource.ready !== false )
			arToolkitContext.update( arToolkitSource.domElement );

		//gui1_team.updateDisplay();
		//gui1_teamapply.updateDisplay();
	}


	function render()
	{
		renderer.render( scene, camera );
	}


	function animate()
	{
		requestAnimationFrame(animate);
		deltaTime = clock.getDelta();
		totalTime += deltaTime;
		update();
		render();
	}

</script>
</body>
</html>